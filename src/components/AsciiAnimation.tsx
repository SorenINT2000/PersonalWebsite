import { useRef, useEffect } from 'react';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import * as THREE from 'three';
import { AsciiEffect } from 'three/addons/effects/AsciiEffect.js';
import { useTheme } from '@mui/material/styles';

/** Low-poly torus knot — useFrame must live inside a Canvas child */
function TorusKnotScene() {
    const meshRef = useRef<THREE.Mesh>(null);

    useFrame(({ clock }) => {
        if (!meshRef.current) return;
        const t = clock.getElapsedTime();
        meshRef.current.rotation.x = -0.25 * Math.PI;
        meshRef.current.rotation.y = 0
        meshRef.current.rotation.z = t * 0.1;
    });

    return (
        <mesh ref={meshRef}>
            <torusKnotGeometry args={[140, 20, 100, 20, 3, 5]} />
            <meshLambertMaterial
                color={0xffffff}
            // flatShading
            />
        </mesh>
    );
}

interface AsciiRendererProps {
    containerRef: React.RefObject<HTMLDivElement | null>;
    fgColor: string;
    bgColor: string;
    resolution: number;
}

/**
 * Side-effect component: hides the default Three.js canvas and replaces it
 * with the HTML table generated by Three's AsciiEffect.
 */
function AsciiRenderer({ containerRef, fgColor, bgColor, resolution }: AsciiRendererProps) {
    const { gl, scene, camera, size } = useThree();
    const effectRef = useRef<InstanceType<typeof AsciiEffect> | null>(null);

    useEffect(() => {
        gl.domElement.style.display = 'none';

        const effect = new AsciiEffect(gl, '.:-*+=%@# ',
            {
                invert: true,
                resolution: resolution,
                strResolution: 'high',
            });

        effect.setSize(size.width, size.height);
        effect.domElement.style.color = fgColor;
        effect.domElement.style.backgroundColor = bgColor;
        effect.domElement.style.position = 'absolute';
        effect.domElement.style.top = '0';
        effect.domElement.style.left = '0';
        effect.domElement.style.width = '100%';
        effect.domElement.style.height = '100%';
        effect.domElement.style.pointerEvents = 'none';

        effectRef.current = effect;

        if (containerRef.current) {
            containerRef.current.appendChild(effect.domElement);
        }

        return () => {
            if (effect.domElement.parentNode) {
                effect.domElement.parentNode.removeChild(effect.domElement);
            }
        };
    }, [gl, size, containerRef, fgColor, bgColor, resolution]);

    useEffect(() => {
        if (effectRef.current) {
            effectRef.current.domElement.style.color = fgColor;
            effectRef.current.domElement.style.backgroundColor = bgColor;
        }
    }, [fgColor, bgColor]);

    useFrame(() => {
        if (effectRef.current) {
            effectRef.current.render(scene, camera);
        }
    }, 1);

    return null;
}

// ─── Main Exported Component ───────────────────────────────────────────────────

interface AsciiAnimationProps {
    /** Ref to the outer container div — the AsciiEffect DOM gets appended here */
    containerRef: React.RefObject<HTMLDivElement | null>;
    /** ASCII resolution — lower = fewer characters = faster. Defaults to 0.15 */
    resolution?: number;
}

export default function AsciiAnimation({
    containerRef,
    resolution = 0.15,
}: AsciiAnimationProps) {
    const theme = useTheme();

    const isDark = theme.palette.mode === 'dark';
    const fgColor = isDark ? 'rgba(144, 202, 249, 1)' : 'rgba(25, 118, 210, 1)';
    const bgColor = isDark ? '#121212' : '#f5f5f5';

    return (
        <Canvas
            key={`${resolution}`}
            camera={{ position: [0, 0, 600], fov: 50 }}
            style={{
                position: 'absolute',
                top: 0,
                left: 0,
                background: 'transparent',
            }}
            gl={{ antialias: true, alpha: true }}
        >
            {/* Near-zero ambient — lets shadow faces be truly dark (space/dot) */}
            <ambientLight intensity={0.02} />
            {/* Key light at moderate intensity — prevents bright faces from all
                clamping to 1.0, so the upper characters get differentiated too */}
            <directionalLight position={[400, 400, 400]} intensity={0.9} />

            <TorusKnotScene />
            <AsciiRenderer
                containerRef={containerRef}
                fgColor={fgColor}
                bgColor={bgColor}
                resolution={resolution}
            />
        </Canvas>
    );
}
